// Base API URL - would come from environment variables in a real app
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'https://api.nexasec.rw';

export interface PentestTarget {
  url: string;
  type: string;
  options: {
    portScan: boolean;
    vulnScan: boolean;
    bruteForce: boolean;
    sqlInjection: boolean;
    xss: boolean;
  };
}

export interface PentestFinding {
  severity: 'critical' | 'medium' | 'low';
  description: string;
  details?: string;
  remediation?: string;
}

export interface PentestResult {
  id: string;
  target: string;
  date: string;
  type: string;
  status: 'completed' | 'in_progress' | 'failed';
  criticalVulnerabilities?: number;
  mediumVulnerabilities?: number;
  lowVulnerabilities?: number;
  findings?: PentestFinding[];
}

// Mock data for penetration test results
const mockPentestResults: PentestResult[] = [
  {
    id: "PT-2023-001",
    target: "https://example.com",
    date: "2023-05-15",
    type: "standard",
    status: "completed",
    criticalVulnerabilities: 2,
    mediumVulnerabilities: 5,
    lowVulnerabilities: 8,
    findings: [
      {
        severity: "critical",
        description: "SQL Injection vulnerability in login form",
        details: "The login form is vulnerable to SQL injection attacks, allowing potential unauthorized access.",
        remediation: "Implement parameterized queries and input validation."
      },
      {
        severity: "critical",
        description: "Outdated SSL/TLS configuration",
        details: "The server is using outdated SSL/TLS protocols that are vulnerable to known attacks.",
        remediation: "Update SSL/TLS configuration to use only secure protocols and ciphers."
      },
      {
        severity: "medium",
        description: "Cross-Site Scripting (XSS) in comment section",
        details: "The comment section does not properly sanitize user input, allowing XSS attacks.",
        remediation: "Implement proper input sanitization and output encoding."
      },
      {
        severity: "medium",
        description: "Missing HTTP security headers",
        details: "Several important security headers are missing, including Content-Security-Policy.",
        remediation: "Configure web server to include all recommended security headers."
      }
    ]
  },
  {
    id: "PT-2023-002",
    target: "192.168.1.10",
    date: "2023-05-20",
    type: "quick",
    status: "completed",
    criticalVulnerabilities: 1,
    mediumVulnerabilities: 3,
    lowVulnerabilities: 5,
    findings: [
      {
        severity: "critical",
        description: "Open SSH port with weak configuration",
        details: "SSH service is using weak ciphers and allowing password authentication.",
        remediation: "Disable password authentication and use only strong ciphers."
      },
      {
        severity: "medium",
        description: "Unnecessary open ports",
        details: "Several unnecessary services are running and exposed to the network.",
        remediation: "Close all unnecessary ports and disable unused services."
      }
    ]
  }
];

export async function runPenetrationTest(target: PentestTarget): Promise<{ success: boolean, message?: string }> {
  try {
    // In a real app, this would be an actual API call
    const response = await fetch(`${API_URL}/api/pentest/run`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(target),
    });
    
    if (!response.ok) {
      throw new Error('Failed to run penetration test');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error running penetration test:', error);
    // For demo purposes, we'll return success
    return { 
      success: true,
      message: "Penetration test completed successfully (mock)"
    };
  }
}

export async function getPentestResults(): Promise<PentestResult[]> {
  try {
    // In a real app, this would be an actual API call
    const response = await fetch(`${API_URL}/api/pentest/results`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch penetration test results');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching penetration test results:', error);
    // Return mock data as fallback
    return mockPentestResults;
  }
}

export async function getPentestResultDetails(id: string): Promise<PentestResult> {
  try {
    const response = await fetch(`${API_URL}/api/pentest/results/${id}`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch penetration test details');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching penetration test details:', error);
    // Return a mock result as fallback
    const result = mockPentestResults.find(r => r.id === id) || mockPentestResults[0];
    return result;
  }
} 